# 中望CAD二次开发学习路径（开发人员）

## 🧭 中望CAD二次开发本质：

> 在 C++ 中开发一个功能类或函数，通过 ZRX/ARX 接口将其封装成一个 CAD 命令，注册后即可像 `LINE`、`CIRCLE` 等原生命令一样，在中望CAD中直接调用，实现自定义的绘图、编辑或数据处理功能。



### 举个最简单的类比：

| 原生命令          | 插件命令（你开发的）               |
| ----------------- | ---------------------------------- |
| `CIRCLE`（画圆）  | `MYCIRC`（画一个带编号的圆）       |
| `LINE`（画线）    | `DRLINE`（自动画一组直线）         |
| `BLOCK`（插图块） | `BATCHBLOCK`（批量插入图块并标注） |



## 🧭二次开发Demo运行指南

### 1. **理解二次开发的基本概念：**

- **二次开发**指的是通过中望CAD的开发工具（SDK）扩展CAD的功能。你可以写插件来**自动化绘图、修改图形**，甚至添加自定义命令，提升工作效率。
- **插件**：你编写的代码会打包成一个 `.zrx` 文件，在中望CAD中加载使用。`.zrx` 文件就像是一个“外挂”，它可以向中望CAD添加额外的功能。

### 2. **准备工作：**

你已经下载了中望CAD SDK，但是可能还没完全了解如何运行程序。我们一步一步来。

#### 第一步：**安装Visual Studio（C++环境）**

你需要用 **Visual Studio** 来开发中望CAD插件。Visual Studio 是用来编写和调试代码的工具，而 C++ 是你开发插件时用的编程语言。

1. 下载并安装 [Visual Studio](https://visualstudio.microsoft.com/)，在安装时选择“C++桌面开发”组件。

#### 第二步：**配置 SDK 和 Visual Studio：**

你已经下载了 SDK，接下来需要把 SDK 与 Visual Studio 配合起来。

1. 在 **Visual Studio** 中创建一个 C++ 项目（选择空项目）。

2. 然后你需要在 Visual Studio 中 **配置 SDK 的路径**，这样才能告诉 VS 去哪里找 SDK 中的文件。

   你需要配置的内容包括：

   - **包含目录**：告诉编译器去哪里找 `.h` 文件。
   - **库目录**：告诉链接器去哪里找 `.lib` 文件。
   - **链接库文件**：告诉链接器需要使用哪些库文件。

------

### 3. **运行 SDK 中的示例程序：**

SDK 中有很多示例程序，它们已经写好了很多常用功能。你可以通过运行这些示例来了解如何进行中望CAD二次开发。

#### 步骤：

1. **找到示例代码**：在你的 SDK 文件夹里，进入 `samples` 文件夹。里面应该有多个示例项目，比如 `circle`、`polyline`、`text` 等。
2. **打开示例代码**：你可以用 Visual Studio 打开这些示例项目，右键点击 `.vcxproj` 文件打开项目。通常，你会看到一些已经写好的简单代码，做的是一些基本操作（比如画一个圆、插入一段文字）。
3. **编译并运行**：点击 Visual Studio 中的【编译】按钮（或者按 `Ctrl + Shift + B`），然后就会生成一个 `.zrx` 文件。
4. **加载到中望CAD**：在中望CAD 中，使用 `APPLOAD` 命令，加载这个 `.zrx` 插件文件，就可以在中望CAD中运行你写的命令了。

------

### 4. **理解示例代码：**

SDK 中的示例代码通常包含了如何使用中望CAD的 API（应用程序接口），这些 API 是中望CAD提供的可以帮助你完成任务的功能。

**例如**，你可能会看到这样的代码片段：

```
cpp复制编辑// 注册命令
acedRegCmds->addCommand(
    L"MYCMDGROUP",   // 命令组
    L"HELLO",         // 用户输入命令
    L"HELLO",         // 显示命令
    ACRX_CMD_MODAL,   // 命令类型
    &myHelloCommand   // 命令执行的函数
);
```

这段代码的作用是**注册一个命令**（例如 `HELLO`），并指定当用户输入这个命令时，执行 `myHelloCommand` 函数。

### 5. **调试和测试：**

你可以使用 **调试功能**，在 Visual Studio 中设置断点，看看程序是如何执行的，跟踪每一行代码的执行。这样有助于你理解中望CAD的二次开发流程。

------

### **简要总结：**

1. **安装和配置**：安装 Visual Studio，配置 SDK 路径。
2. **运行示例代码**：在 SDK 的 `samples` 文件夹中找到现有的示例程序，编译并运行它们，了解基础操作。
3. **理解代码和 API**：逐步分析示例代码，学习如何用 C++ 编写中望CAD插件。
4. **调试和测试**：通过 Visual Studio 调试代码，查看命令执行效果。

------

### 🎯 进阶学习：

一旦你了解了这些基础操作，可以逐步开始编写自己的插件，注册自己的命令，开始接触实际的二次开发任务。你可以继续利用 SDK 示例中的代码作为模板，逐步开发更复杂的功能。

















## ✅ Visual stdio 二次开发的配置



1  ` #include <xxx.h>` 用于声明要使用的函数或类，但编译器需要通过“附加包含目录”来知道这些头文件的位置。
 2  `.lib` 文件是 SDK 中已编译好的函数实现代码，必须通过“附加依赖项”和“附加库目录”在链接阶段加入，不能使用 `#include` 来导入。

| 文件   | 比喻           | 是否 `#include`        | 是否链接配置             |
| ------ | -------------- | ---------------------- | ------------------------ |
| `.h`   | 函数说明书     | ✅ 要                   | ❌ 不用                   |
| `.cpp` | 你写的内容     | ✅ 要（包含自己写的类） | ❌ 不需要链接             |
| `.lib` | 封装好的工具箱 | ❌ 不用                 | ✅ 必须配置               |
| `.dll` | 动态工具箱     | ❌ 不用                 | ✅ 运行时加载（高级阶段） |

在使用 Visual Studio 开发中望CAD（ZRX）插件时，需要配置好 SDK 的头文件和库文件，使项目能够正常调用中望提供的类和函数。

---

> 



让 Visual Studio 知道：

- `.h` 头文件在哪 → 编译时能识别类/函数名
- `.lib` 库文件在哪 → 链接时能找到函数实现

---

#### ✅ 必要配置（共三步）

##### 1. 配置头文件路径（用于编译）

路径设置位置：

> 项目 → 属性 → C/C++ → 常规 → 附加包含目录

添加路径：<ZRX_SDK目录>\inc

作用：支持 `#include "dbents.h"` 等头文件引用，识别 SDK 提供的类。

---

##### 2. 配置库文件路径（用于链接）

路径设置位置：

> 项目 → 属性 → 链接器 → 常规 → 附加库目录

添加路径：zcad.lib zrxapi.lib

---

##### 3. 添加链接库文件名（用于功能实现）

设置位置：

> 项目 → 属性 → 链接器 → 输入 → 附加依赖项

添加常用库名：zcad.lib zrxapi.lib

这两个是基本插件开发必须链接的核心库，其他功能库如 `zdim.lib` 可根据需要添加。

---

#### ✅ 补充说明

- `.h` 文件负责**声明接口**，必须 `#include`。
- `.lib` 文件负责**提供实现**，必须通过链接器显式配置。
- 两者配合使用，编译器和链接器才能完成插件构建。

---

#### ✅ 常见库说明（按需添加）

| 库名       | 功能说明                       |
| ---------- | ------------------------------ |
| zcad.lib   | 图形实体、数据库操作等核心功能 |
| zrxapi.lib | 插件注册、命令系统支持         |
| zdim.lib   | 尺寸标注相关功能               |
| zge.lib    | 几何运算功能（点线面）         |

---

> 🔧 完成以上配置后，即可在代码中使用 `ZwDbCircle`、`acedGetPoint` 等类与函数，生成 `.zrx` 插件供中望CAD 加载使用。









### 1，CAD/中望CAD上手学习

以b站视频为主 看一周b站视频吧

我直接看的中望cad 没看autocad



#### 目的：了解操作即可 为后续二次开发做准备  无需掌握太深





#### 3-21  下载+入门

1 熟悉中望界面 和cad区别不大   

重点是 右下角的经典模式   



3 查看移动复制删除在右边的侧边栏



4-5 圆和圆弧  

分别在上方的绘制里寻找各种画法



**` 空格的使用  空格是确认上一步操作`**



**` CAD的快捷键、工具栏按钮和菜单栏命令功能一致，使用哪种方式取决于个人习惯，操作效果相同，选择最顺手的即可。`**



6 多段线

多段线是一体的 和直线的最大区别

另外，还可以更改每一段的起点宽度和终点宽度  因此可以画出箭头



具体怎么操作感觉不重要 需要的时候复习即可



#### 3.24 继续cad入门

7  界面显示调整

页面左边 上边  右边的操作栏出现与否 



`在右下角的设置工作空间那里  图标是个小齿轮` 





`另外  指令option可以打开设置栏 设置一些显示的东西  仅此而已`





8 画正多边形

很简单   流程如下：

选边数N----选圆心e----选是外接圆还是内切圆  





9 修剪延伸

没啥可看的





10 镜像

操作有点抽象 但是不影响写代码应该



11 偏移

就是一条线往上下左右偏移多少m   用来画一些固定距离的而已

但是和直接画直线输入距离好像没区别啊



12-15   缩放 旋转 对齐缩放  拉伸

基本都顾名思义  需要的时候回顾即可



整体流程都是：

`找到点哪/快捷键-------操作`



18 多段线 

将多个单独的直线合并成多段线





记录下操作吧



（1）`输入Pedit`

（2） 选择要合并的多段线

（3） 键盘输入m  不知道为啥  然后选择拟合还是合并

（4）模糊距离 大概意思是断开的也链接  有的话按照需要输入 没有就直接空格

（5）退出



、

19 阵列 

没什么意义  只是重复画多个同一种图形的工具

需要去看即可





#### 3.25 下一步软件操作规划

##### 1. 图层管理
   - **学习内容：** 学习如何在中望CAD中创建、删除、修改图层，设置图层的属性（如颜色、线型、线宽等），并掌握如何通过图层来管理和操作不同的图形元素。
   - **为什么学？** 图层管理是二次开发中的基础操作，后续开发过程中，常常需要基于图层进行对象选择、批量操作等。

##### 2. 图块管理
   - **学习内容：** 学习如何创建、插入、修改和删除图块，了解图块的属性，掌握如何通过图块提高绘图效率，并在 CAD 中管理图块的显示、编辑等功能。
   - **为什么学？** 图块在 CAD 中用于将常用元素存储为一个“模块”，通过图块可以提高开发效率，批量插入和管理元素是二次开发中常见的任务。

##### 3. 属性管理与数据提取
   - **学习内容：** 学习如何获取和修改图形对象的属性（如颜色、图层、线型等），如何通过代码操作图形的属性，并了解如何提取图形的几何数据（如长度、面积等）。
   - **为什么学？** 在二次开发中，很多时候你需要通过编程获取图形的属性或修改其属性，掌握这一点可以使你在插件开发中更高效地操作图形。

##### 4. 高级选择集与筛选
   - **学习内容：** 学习如何基于不同条件（如图层、颜色、类型等）选择和筛选图形对象，了解如何操作选择集，实现批量选择和修改图形的功能。
   - **为什么学？** 选择集是二次开发中非常常见的操作，能够帮助你高效地对多个图形对象进行批量操作，特别是在处理大量数据时。

##### 5.    数据导出与图形交互
   - **学习内容：** 学习如何将图形数据导出到其他格式（如 Excel、CSV 等），了解如何通过插件实现图形与外部数据的交互，进行图形数据的导入导出。
   - **为什么学？** 在二次开发中，很多应用场景需要与外部系统或数据交互，掌握数据导出与图形交互将使你能够在插件中实现更加复杂和多样的功能。

---

> **总结：**  
> 以上这些操作是中望CAD二次开发中非常常见且核心的操作，学习和掌握它们将为你后续的插件开发打下坚实的基础。每一步的学习都能帮助你理解如何在实际开发中使用这些操作来提高效率和实现功能。





#### 3.26-3.27 根据gpt选择性学习cad功能

##### 1 图层

![1-1](cadpicture/1-1.PNG)



`图层的基本操作：`

1. **每个图形对象都有图层**：
   - 在 **ZWCAD** 中，每个你绘制的对象（如线条、圆形、矩形等）都会默认属于一个图层。每个图层都可以设置不同的属性，例如颜色、线型、线宽等。
   - 你可以通过设置图层来控制这些对象的显示样式和管理它们。
2. **新建图层**：
   - 你可以随时创建新的图层来组织不同类型的图形。比如，你可以创建一个图层专门用于绘制建筑物的墙壁，另一个图层用于绘制门窗。
   - **操作**：在图层管理器中，点击“新建图层”按钮，输入图层名称，并设置相关属性（如颜色、线型、线宽等）。
3. **修改对象的图层**：
   - 如果你已经绘制了对象，并且希望将它们移到不同的图层，你可以随时修改它们的图层。
   - **操作**：选择对象，然后在属性栏或者图层管理器中更改其图层。
4. **图层的显示和管理**：
   - **冻结/解冻图层**：你可以冻结不需要显示的图层，这样可以提高绘图性能，特别是当图纸复杂时。冻结的图层中的内容不会显示，但不会被删除。
   - **锁定/解锁图层**：你可以锁定某些图层，防止它们被编辑。这样可以保护你不小心修改重要的图层内容。
   - **设置图层的颜色、线型、线宽等**：你可以对不同图层设置不同的颜色、线型和线宽，以便更容易区分不同类型的图形。



具体的操作及其简单 

（1）`左边红框`点开图层编辑，可以`新建`，`显示`，冻结，锁定图层

（2）`右边的红框`是对于自己画的图   `直接选中就可以调整图层`

![1-2](cadpicture/1-2.PNG)

1. **对图层的理解保持现状即可**：
    ✔ 知道怎么新建图层
    ✔ 知道一个图形属于哪个图层
    ✔ 知道怎么切换图层、修改图形图层
    ❗图层表、属性继承、事件监听这些——**不用学！现在还不是时候**
2. **后面学代码时再深入图层机制也不迟**：
    到你开始写 ZRX 插件的那一步，我们再来系统性告诉你“如何在 C++ 中读取图层、设置图层、操作图层对象”，那个时候你已经知道CAD里图层是怎么工作的，学起来自然更轻松。



##### 2 设计中心

**设计中心（DesignCenter）** 在 **CAD（包括中望CAD和AutoCAD）** 中，确实就是一个 **资源管理器**，用来方便地从其他图纸或文件中 **导入各种样式、图块、图层、文字样式等资源**





具体位置：

工具---选项板---设计中心      或者直接ctrl+2



`设计中心可以让你 **重用已存在的资源**，避免重复绘制图形或重新设置样式，提高设计效率。`





##### 3, 工具选项板

就是一些内置的形状图形 也可以把自己画的拉进去

ctrl+3



##### 4 尺寸标注

这里有点绕，简单来说分为`单个对象标注`和`尺寸标注`

1 **单个对象标注**是针对 **单一图形对象**（如直线、弧线）的尺寸进行标注，通常只标记其长度或半径等基础尺寸；

2 而**尺寸标注**则涉及 **多个对象之间的尺寸关系**，`比如两条线段的距离、角度或对齐尺寸等`。

两者的本质相同，都是通过选择基准点或对象来计算并显示尺寸，唯一的区别在于**尺寸标注**需要处理多个对象之间的关系，代码实现会更复杂一些。





##### 5，图块vs图层

| 特性     | 图层                             | 图块                           |
| -------- | -------------------------------- | ------------------------------ |
| 作用     | 管理和控制显示、编辑、打印等     | 封装和复用复杂图形元素         |
| 示例     | 墙、窗、门可以设置属于不同的图层 | 螺丝、门、灯具等图块           |
| 控制对象 | 对象的显示方式、属性等           | 图形元素的插入、修改等         |
| 修改方式 | 影响图形的显示和属性             | 修改一个图块，所有实例同步更新 |

![](cadpicture/1-3.PNG)



##### 插入图块的两种方式

###### 1. **保存图块在 CAD 内部并插入**
- **步骤**：
  1. 选择你要保存的图形，右键点击，选择 `块` > `定义块`。
  2. 在弹出的对话框中设置块的名称，选择基点，点击 `确定`。
  3. 插入图块：点击 `插入` > `块`，选择保存的块名称，点击 `确定`。

###### 2. **保存图块到本地文件然后导入**
- **步骤**：
  1. 将图块保存为外部文件：选择图形，右键点击，选择 `块` > `导出块`。   `或者直接wblock 我没找到点哪`
  2. 选择保存路径，点击 `保存`。
  3. 插入图块：点击 `插入` > `块` > `插入外部图块`，选择保存的文件，点击 `确定`。







##### 6.属性

`属性就是自定义的图块附加信息`

| 特性         | 直线的几何特性                         | 图块的属性                                   |
| ------------ | -------------------------------------- | -------------------------------------------- |
| **内容**     | 只包括几何数据（如长度、角度、坐标等） | 用户自定义的附加信息（如材质、颜色、编号等） |
| **自动生成** | 是的，自动计算并显示                   | 用户手动定义和赋值                           |
| **作用**     | 描述图形的几何形状和位置               | 描述图块的特性和附加信息                     |
| **可定制性** | 不可以自定义，只能查看和使用已有的特性 | 可以完全自定义属性，定义任意需要的内容       |
| **示例**     | 直线的起点坐标、终点坐标、长度、角度等 | 门的宽度、颜色、编号、材质等                 |

### 

#   二次开发学习

## 一，Visual stidio项目框架

```markdown
css复制编辑项目根目录/
├── Header Files/         ← 放头文件（.h）
│   ├── framework.h
│   ├── helloworld.h
│   ├── pch.h
│   ├── resource.h
│   └── targetver.h
├── Resource Files/       ← 放资源界面（.rc）
│   ├── 项目名.rc
│   └── 项目名.rc2
├── Source Files/         ← 放功能实现（.cpp）
│   ├── helloworld.cpp
│   ├── och.cpp
│   ├── rxentrypoint.cpp
│   └── 项目名.cpp
```

### 📁 Header Files（头文件）

| 文件名         | 功能简要说明                                                 |
| -------------- | ------------------------------------------------------------ |
| `framework.h`  | 公共头文件，包含 MFC 和 ZRX 的基础库，一般不改。             |
| `helloworld.h` | 声明 `helloworld.cpp` 中的命令或功能函数。                   |
| `pch.h`        | ✅ **预编译头文件**，提前引入 CAD 插件开发常用的头文件，加快编译速度。 |
| `resource.h`   | 自动生成，定义资源控件的 ID（按钮、输入框等）。              |
| `targetver.h`  | 设置目标 Windows 平台版本，一般保持默认即可。                |

#### 📁 `pch.h` 文件详细说明

> `pch.h` 是项目中的预编译头文件，**作用是统一引入一些“常用但不会经常改动的头文件”**，加快编译速度，同时让你写代码更轻松（不需要每个 .cpp 文件都重复 include）。

它通常包含以下内容：

```cpp
#include "framework.h"      // Windows 和 MFC 的基础支持
#include "resource.h"       // 控件 ID

// ZRX 插件常用的头文件：
#include "accmd.h"          // 命令注册
#include "AcString.h"       // 处理字符串
#include "gepnt3d.h"        // 三维点类 AcGePoint3d
#include "geassign.h"       // 几何赋值
#include "dbents.h"         // 图元（圆、线等）类
#include "dbmain.h"         // 数据库操作
#include "acdocman.h"       // 文档管理器
#include "acarray.h"        // CAD 数组类型
#include "adscodes.h"       // 数据结构编码
```

---

### 📁 Resource Files（资源文件）

| 文件名       | 功能简要说明                                       |
| ------------ | -------------------------------------------------- |
| `项目名.rc`  | 主资源文件，用于设计界面（对话框、按钮、图标等）。 |
| `项目名.rc2` | 附加资源文件，一般不修改，用于合并外部资源。       |

---

### 📁 Source Files（源文件）

| 文件名             | 功能简要说明                                                 |
| ------------------ | ------------------------------------------------------------ |
| `helloworld.cpp`   | 示例命令的功能实现，比如输出 Hello World。                   |
| `och.cpp`          | 实现另一个模块/命令的功能。                                  |
| `rxentrypoint.cpp` | 🔥 **命令注册入口**：包含 `acrxEntryPoint` 函数，注册/注销命令。 |
| `项目名.cpp`       | DLL 启动入口：包含 `DllMain`，控制 DLL 加载/卸载，一般不用动。 |

---

### 🎯 项目开发重点关注：

| 文件名             | 是否重点 | 原因                                      |
| ------------------ | -------- | ----------------------------------------- |
| `rxentrypoint.cpp` | ✅ 是     | 注册你写的命令（通过 `acrxEntryPoint`）。 |
| `helloworld.cpp`   | ✅ 是     | 写功能代码（如画圆、弹窗等）的位置。      |
| `项目名.rc`        | ✅ 是     | 添加对话框、按钮等界面资源。              |

---

### 🧠 一句话总结结构：

> `.cpp` 写功能，`.h` 声明接口，`.rc` 设计界面，`rxentrypoint.cpp` 注册命令，`项目名.cpp` 管 DLL 加载。





## 二，二次开发流程

无论你将来是“画线”、“选择图元”、“修改图层”、“弹出窗口设置属性”等等，都会经历以下几步：

| 步骤 | 内容                 | 说明                                              |
| ---- | -------------------- | ------------------------------------------------- |
| 1    | 添加资源文件（UI）   | 如果需要弹窗、按钮，就在 `.rc` 中添加对话框       |
| 2    | 生成对应的对话框类   | 通过右键对话框 → 添加类 → 自动生成 `.h/.cpp` 文件 |
| 3    | 写界面逻辑函数       | 比如按钮点击后干什么，写在刚才生成的 `.cpp` 中    |
| 4    | 写命令函数           | 写一个 C++ 函数，调用这个对话框（比如弹出窗口）   |
| 5    | 注册命令入口         | 把命令注册到主文件 `ZrxProject2.cpp` 中           |
| 6    | 编译 -> 加载 -> 测试 | 在 CAD 中加载 `.zrx` 插件测试                     |

我们下面用结构树 + 详细解释的方式讲解，每一步都明确说“在哪建、在哪写、文件名是什么”。

------

### 🔹 第一步：添加资源（UI界面）

🗂️ 所在位置：

> 解决方案资源管理器 → Resource Files（资源文件）
>  打开 `.rc` 文件（点开就进入资源视图）

📝 你要做的：

- 右键 `.rc` 文件 → 添加 → 对话框（Dialog）
- Visual Studio 会自动生成一个对话框资源，ID 例如是 `IDD_CIRCLE_DIALOG`

💡 这是你拖按钮、输入框的地方。

------

### 🔹 第二步：添加一个对话框类（自动生成 .h/.cpp）

🗂️ 所在位置：

> 对话框控件 → 右键 → 添加类 → MFC类
>  自动生成以下两个文件：

| 文件夹       | 文件名             | 内容               |
| ------------ | ------------------ | ------------------ |
| Header Files | `CircleDialog.h`   | 类的声明           |
| Source Files | `CircleDialog.cpp` | 类的实现（写逻辑） |

🔧 自动生成的类名会是 `CCircleDialog`（你可以自定义），文件也对应。

------

### 🔹 第三步：写按钮点击的逻辑（比如点击“确定”去画圆）

🗂️ 所在位置：

> 文件 `CircleDialog.cpp`（刚刚自动生成的）

📝 做法：

1. 找到 `BEGIN_MESSAGE_MAP(...)` 的位置
2. 在其中添加：哪个按钮点击时调用哪个函数
3. 然后在下面写这个函数，比如：点击“确定”按钮后读取输入框的内容，去画图

------

### 🔹 第四步：写一个命令函数，让用户输入命令就弹出这个界面

🗂️ 所在位置：

> Source Files → 你手动添加两个文件：

| 文件夹       | 文件名                  | 内容                         |
| ------------ | ----------------------- | ---------------------------- |
| Header Files | `ShowDialogCommand.h`   | 声明命令函数（可跳过不写）   |
| Source Files | `ShowDialogCommand.cpp` | 实现命令函数（比如弹出窗口） |

📄 文件中你会写个函数叫 `ShowCircleDialog()`，里面就一行：弹出 `CCircleDialog`。

------

### 🔹 第五步：主文件中注册命令

🗂️ 所在位置：

> 项目自动生成的主文件（一般在 Source Files 中）

文件名通常是：`ZrxProject2.cpp`

📝 在这个文件中添加：

- `#include "ShowDialogCommand.h"`（或者直接声明函数也可以）
- `acrxEntryPoint` 函数中注册命令 `ShowCircleDialog`

------

### 🌲 总体文件结构总结图：

```ts
MyZRXProject/
├── Header Files/
│   ├── CircleDialog.h          // 自动生成的界面类头文件
│   └── ShowDialogCommand.h     // 可选，命令函数的声明
├── Resource Files/
│   └── MyZRXProject.rc         // 资源文件，包含对话框
├── Source Files/
│   ├── CircleDialog.cpp        // 自动生成的界面类实现
│   ├── ShowDialogCommand.cpp   // 你自己写的命令函数（弹出对话框）
│   └── ZrxProject2.cpp         // 主入口，注册命令
```



## 三， 🧩 ZRX 和 ARX 的关系

### 1. **共同点：** 🤝
- **ZRX** 和 **ARX** 都是基于 **ObjectARX** 技术开发的，目的是扩展 **AutoCAD** 或 **中望CAD** 的功能。
- **ZRX** 和 **ARX** 都使用 **C++** 作为开发语言。
- 都允许开发者通过插件的方式扩展 **AutoCAD** 或 **中望CAD** 的功能，支持命令注册、图元操作、图形数据库管理等。

### 2. **兼容性：** 🔄
- **ZRX** 是 **中望CAD** 特有的二次开发平台，和 **AutoCAD** 的 **ARX** 开发非常类似。
- **ZRX** 和 **ARX** 在 **核心开发框架** 和 **API** 上非常相似，**ZRX 兼容 ARX API**，这意味着你可以在 **ZRX 中使用大部分 ARX 的 API**。
- 然而，**ZRX** 为了与 **中望CAD** 兼容，对一些 **类和命名空间** 做了 **封装**，所以你在 **ZRX 中使用 ARX API 时，需要替换为 ZRX 的类**。

### 3. **差异：** ⚖️
- **类和命名空间的前缀不同**：
  - **ARX** 使用的类名通常以 **`Ac`** 开头，如 `AcDbLine`、`AcGePoint3d`。
  - **ZRX** 使用的类名通常以 **`Zc`** 开头，如 `ZcDbLine`、`ZcGePoint3d`。
- **ZRX 中的命名空间和类** 是专门为 **中望CAD** 设计的，适应其特定的功能和结构。

### 4. **总结：** 🔑
- 在 **中望CAD ZRX** 开发中，很多功能都可以直接使用 **AutoCAD ARX 的代码**，因为 **ZRX 与 ARX 兼容**，而且大部分 API 是相似的。你可以先尝试使用 **ARX 的代码** 来实现大部分功能，如果遇到某些特定问题或需求，再考虑使用 **ZRX 自己的独有 API** 来解决。
- （如 `ZcDbLine`、`ZcGePoint3d` 替代 `AcDbLine`、`AcGePoint3d`）。





## 四，二次开发初解

### 绘制直线

#### 1. **获取块表（Block Table）**

```c++
AcDbBlockTable *pBlockTable;
acdbHostApplicationServices()->workingDatabase()->getBlockTable(pBlockTable, AcDb::kForRead);
```

- **块表** 可以理解为 **图形的管理者**。它管理图形中的所有块（包括模型空间中的元素）。不过你可以忽略这个部分，直接认为它是用来帮助我们获取模型空间的。

#### 2. **获取模型空间记录**

```cpp
AcDbBlockTableRecord *pBlockTableRecord;
pBlockTable->getAt(ACDB_MODEL_SPACE, pBlockTableRecord, AcDb::kForWrite);
```

- **模型空间记录**：可以理解为 **模型空间的“位置”**。我们想要在模型空间中添加图形，首先得拿到这个“位置”。

#### 3. **创建一个线条**

```cpp
AcGePoint3d ptStart(0, 0, 0);  // 起点
AcGePoint3d ptEnd(100, 100, 0);  // 终点
AcDbLine *pLine = new AcDbLine(ptStart, ptEnd);
```

- **创建线条**：通过这段代码，我们创建了一条 **从 (0, 0, 0) 到 (100, 100, 0)** 的线条。可以把它理解成 **实例化** 一个对象（类似 Java 中的 `new` 操作），这里 `pLine` 就是那条线的对象。

#### 4. **把线条添加到模型空间**

```cpp
pBlockTableRecord->appendAcDbEntity(lineId, pLine);
```

- **添加到模型空间**：这段代码就是把我们创建的线条 **添加到模型空间** 中，相当于把它放到了画布上。

#### 5. **释放资源**

```cpp
pLine->close();
pBlockTableRecord->close();
pBlockTable->close();
```

- **关闭和释放**：就像 Java 中我们会关闭打开的文件一样，这段代码是为了释放之前使用的资源，确保内存不被浪费。

------

### 🚀：用 Java 思维来类比**

你可以把这段代码理解成一个 **Java 程序中的对象创建和管理** 过程：

1. **创建对象**：就像你在 Java 中使用 `new` 创建一个对象（例如：`Line line = new Line(start, end);`），在这段代码中，我们也是通过 `new` 来创建一条线。
2. **存储对象**：在 Java 中，我们会把对象存储到 **集合** 或 **数组** 中，在这段代码里，线条被存储到了 **模型空间** 中（模型空间类似于一个容器）。
3. **清理资源**：就像 Java 中使用 `finally` 关闭资源一样，这段代码最后调用 `close()` 来清理资源，确保程序不占用多余的内存。

------

### 🚀 **：总结这段代码的目的**

1. **获取模型空间**：代码的目的是先获取 **模型空间**，这是你用来绘制图形的地方。
2. **创建图形（线条）**：然后，它创建了 **一条从起点到终点的线**。
3. **将图形添加到模型空间**：接着，把这条线 **放入模型空间** 中，就像你把对象存储到集合里一样。
4. **释放资源**：最后，**释放资源**，确保不会浪费内存。

### 🚀 **最终结论：**

- **模型空间**：可以理解为 **画布**，你在上面绘制图形。
- 代码的作用：将你 **创建的图形**（比如线条） **添加到模型空间** 中，并且完成一些资源管理工作。





### 中望官方demo---绘制图块并添加

#### 1，代码

```C++
void CBlockTest::createBlockTest1()
{
	// 获取当前工作数据库
	AcDbDatabase* pDatabase = acdbHostApplicationServices()->workingDatabase();

	Acad::ErrorStatus es;
	AcDbBlockTable* pBlockTable = NULL;            // 块表对象
	AcDbBlockTableRecord* pBlockTableRecord = NULL; // 块记录对象

	TCHAR szBlock1[20] = _T("szBlock1");  // 图块名称

	// 获取块表（写入模式）
	es = pDatabase->getBlockTable(pBlockTable, AcDb::kForWrite);

	// 如果块表中已存在该图块
	if (pBlockTable->has(szBlock1))
	{
		pBlockTable->close();
		acutPrintf(_T("\nBlock already exist!"));  // 打印已存在的消息
		return;
	}
	else
	{
		// 如果图块不存在，创建新的块记录
		pBlockTableRecord = new AcDbBlockTableRecord();
		pBlockTableRecord->setName(szBlock1);  // 设置图块名称
		pBlockTableRecord->setOrigin(AcGePoint3d(1000, 1000, 0));  // 设置图块的原点位置
		pBlockTable->add(pBlockTableRecord);  // 将块记录添加到块表中

		// 创建一个圆，并添加到图块中
		AcDbCircle* pCircle = new AcDbCircle(AcGePoint3d(1000, 1000, 0), AcGeVector3d::kZAxis, 200);
		pBlockTableRecord->appendAcDbEntity(pCircle);  // 将圆添加到图块记录中
		pCircle->close();  // 关闭圆实体

		// 创建两条直线，并添加到图块中
		AcDbLine* pLine1 = new AcDbLine(AcGePoint3d(1000, 750, 0), AcGePoint3d(1000, 1250, 0));
		pBlockTableRecord->appendAcDbEntity(pLine1);
		pLine1->close();  // 关闭直线实体

		AcDbLine* pLine2 = new AcDbLine(AcGePoint3d(750, 1000, 0), AcGePoint3d(1250, 1000, 0));
		pBlockTableRecord->appendAcDbEntity(pLine2);
		pLine2->close();  // 关闭第二条直线实体

		// 获取模型空间记录
		AcDbBlockTableRecord* pMSBlockTableRecord = NULL;
		es = pBlockTable->getAt(ACDB_MODEL_SPACE, pMSBlockTableRecord, AcDb::kForWrite);
		pBlockTable->close();  // 关闭块表

		// 创建图块引用，将其添加到模型空间
		AcDbBlockReference* pBlkRef = new AcDbBlockReference();
		pBlkRef->setDatabaseDefaults();  // 设置数据库默认值
		pBlkRef->setBlockTableRecord(pBlockTableRecord->objectId());  // 设置图块引用的块表记录
		pBlkRef->setPosition(pBlockTableRecord->origin());  // 设置图块引用的位置
		pBlkRef->setScaleFactors(1.0);  // 设置缩放比例
		pBlkRef->setRotation(0.0);  // 设置旋转角度

		es = pMSBlockTableRecord->appendAcDbEntity(pBlkRef);  // 将图块引用添加到模型空间
		pMSBlockTableRecord->close();  // 关闭模型空间记录

		pBlkRef->close();  // 关闭图块引用
		pBlockTableRecord->close();  // 关闭图块记录
	}
}
```

#### 2，图块记录和图块引用

**图块记录（Block Table Record）** 就像是一个 **类的定义**，它描述了图块的结构（比如包含哪些图元），但是它本身并没有实际出现在模型空间中。

**图块引用（Block Reference）** 则像是一个 **类的实例**，当你真正想要在模型空间中显示这个图块时，你会创建一个图块引用实例，它才是 **实际显示的内容**。

| 特性   | 图块记录（`AcDbBlockTableRecord`）     | 图块引用（`AcDbBlockReference`）            |
| ------ | -------------------------------------- | ------------------------------------------- |
| 角色   | **定义** 图块的结构和内容              | **插入** 图块实例到模型空间                 |
| 内容   | 包含图块的组成实体（如线、圆、文本等） | 引用图块记录的内容，显示在模型空间          |
| 位置   | 存储在 **块表** 中                     | 存储在 **模型空间** 中                      |
| 复用性 | 不直接显示，**只定义** 图块            | 多次引用同一个图块，可以在不同位置 **显示** |

------



### 面域：自己依靠GPT编写

我们把之前“选图 → 转面域 → 插入到模型空间”这整个流程，**按照职责划分成3个函数**，清晰、可重用、便于后续维护。

------

#### ✅ 函数职责划分

| 函数名称                 | 功能说明                                    |
| ------------------------ | ------------------------------------------- |
| `getSelectedCurves`      | 鼠标选择图元，提取为可用的曲线对象（Curve） |
| `convertToRegions`       | 将选中的曲线对象转换成面域对象              |
| `addRegionsToModelSpace` | 将生成的面域插入 CAD 的模型空间中           |

------

#### ✅ 函数 1：选择图元并返回曲线对象数组

```
AcArray<AcDbCurve*> getSelectedCurves()
{
    AcArray<AcDbCurve*> curves;
    ads_name ss;
    if (acedSSGet(NULL, NULL, NULL, NULL, ss) != RTNORM) {
        acutPrintf(_T("\n未选择任何图形。"));
        return curves;
    }

    long len = 0;
    acedSSLength(ss, &len);

    for (int i = 0; i < len; ++i) {
        ads_name entName;
        acedSSName(ss, i, entName);

        AcDbObjectId objId;
        if (acdbGetObjectId(objId, entName) != Acad::eOk)
            continue;

        AcDbEntity* pEnt = nullptr;
        if (acdbOpenObject(pEnt, objId, AcDb::kForRead) != Acad::eOk)
            continue;

        AcDbCurve* pCurve = AcDbCurve::cast(pEnt);
        if (pCurve != nullptr) {
            pCurve->upgradeOpen();  // 转为写模式，以供处理
            curves.append(pCurve);
        }
        else {
            pEnt->close();  // 非 Curve 的直接关闭
        }
    }

    acedSSFree(ss);
    return curves;
}
```

------

#### ✅ 函数 2：将曲线对象转换为面域对象

```
AcArray<AcDbRegion*> convertToRegions(const AcArray<AcDbCurve*>& curves)
{
    AcArray<AcDbRegion*> regions;
    if (curves.isEmpty()) {
        acutPrintf(_T("\n没有有效的曲线用于创建面域。\n"));
        return regions;
    }

    Acad::ErrorStatus es = AcDbRegion::createFromCurves(curves, regions);
    if (es != Acad::eOk) {
        acutPrintf(_T("\n创建面域失败，请确保曲线闭合且不自交。\n"));
    }

    // 清理 curve 对象（已经用过了）
    for (int i = 0; i < curves.length(); ++i) {
        curves[i]->close();
    }

    return regions;
}
```

------

#### ✅ 函数 3：将面域插入模型空间

```
void addRegionsToModelSpace(const AcArray<AcDbRegion*>& regions)
{
    if (regions.isEmpty()) {
        acutPrintf(_T("\n没有可添加的面域。\n"));
        return;
    }

    AcDbBlockTable* pBT = nullptr;
    AcDbBlockTableRecord* pMS = nullptr;

    acdbHostApplicationServices()->workingDatabase()->getBlockTable(pBT, AcDb::kForRead);
    pBT->getAt(ACDB_MODEL_SPACE, pMS, AcDb::kForWrite);
    pBT->close();

    for (int i = 0; i < regions.length(); ++i) {
        AcDbRegion* pRegion = regions[i];
        AcDbObjectId objId;
        pMS->appendAcDbEntity(objId, pRegion);
        pRegion->close();  // 插入后自动归数据库管理，需关闭
    }

    pMS->close();
    acutPrintf(_T("\n已成功添加 %d 个面域到模型空间。\n"), regions.length());
}
```

------

#### ✅ 主流程函数（命令）

你可以写一个命令入口，串联上面这三个函数：

```
void cmd_CreateRegionsFromSelection()
{
    AcArray<AcDbCurve*> curves = getSelectedCurves();
    AcArray<AcDbRegion*> regions = convertToRegions(curves);
    addRegionsToModelSpace(regions);
}
```

注册命令：

```

acedRegCmds->addCommand(_T("REGION_DEMO"), _T("SelToRegion"), _T("SelToRegion"), ACRX_CMD_MODAL, cmd_Crea
```



### Zrx二次开发初步总结：

1 GPT的使用具有一定问题 会编造一些不存在的api  还是要自己去看api文档

2 目前还不会写页面去交互   需要去学mfc











## 五，MFC图形化交互

### 💡 在 ZRX 插件中用 MFC 创建一个带编辑框的对话框（实用步骤）

#### ✅ 步骤 1：添加对话框资源

- 在资源视图中右键 `.rc` 文件 → 添加 → 对话框
- 拖一个编辑框控件（ID：`IDC_EDIT1`）
- 拖两个按钮（ID：`IDOK` 和 `IDCANCEL`）
- 可在属性中设置标题和控件提示文字

------

#### ✅ 步骤 2：为对话框添加 MFC 类

- 右键对话框 → 添加类（基类选 `CDialogEx`）
- 类名设置为：`CDialog1`
- 生成两个文件：`CDialog1.h` 和 `CDialog1.cpp`

------

#### ✅ 步骤 3：在头文件中添加成员变量

```cpp
 CDialog1.h
public:
	CString m_editText; // 绑定编辑框内容
```

------

#### ✅ 步骤 4：在 `DoDataExchange` 中绑定控件

```cpp
// CDialog1.cpp
void CDialog1::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
	DDX_Text(pDX, IDC_EDIT1, m_editText); // 控件 ↔ 成员变量绑定
}
```

------

#### ✅ 步骤 5：添加按钮点击响应函数

```cpp
void CDialog1::OnBnClickedOk()
{
	UpdateData(TRUE); // 把控件内容读入变量
	acutPrintf(_T("你输入的是：%s\n"), m_editText); // 输出到命令行
	CDialogEx::OnOK(); // 关闭窗口
}

void CDialog1::OnBnClickedCancel()
{
	m_editText = _T(""); // 清空内容
	UpdateData(FALSE);   // 把空字符串写回控件
	// 不关闭窗口
}
```

> 注意：如果不调用 `OnOK()` 或 `OnCancel()`，窗口不会关闭，会导致 CAD 卡死！

------

#### ✅ 步骤 6：注册命令以弹出窗口

```cpp
void ShowDialog1()
{
	CDialog1 dlg;
	dlg.DoModal(); // 模态方式打开窗口
}

acedRegCmds->addCommand(_T("MY_CMDS"), _T("ShowDialog1"), _T("ShowDialog1"), ACRX_CMD_MODAL, &ShowDialog1);
```

------

#### ✅ 步骤 7：在 CAD 中测试

1. 使用 `APPLOAD` 加载插件
2. 命令行输入 `ShowDialog1` 回车
3. 弹出窗口 → 输入文字 → 点“确定”打印 → 点“取消”清空输入



### 模态弹出和非模态弹出

| 模式                     | 是否阻塞主窗口              | 举个例子                                             |
| ------------------------ | --------------------------- | ---------------------------------------------------- |
| ✅ **模态（Modal）**      | 会阻塞，不能点击 CAD 主界面 | 打开一个“设置”弹窗，必须点“确定”或“取消”才能继续操作 |
| ✅ **非模态（Modeless）** | 不阻塞，可以同时操作主界面  | 弹出一个工具条窗口，一边输入参数一边还能画图         |

















## 六，现有插件引入

✅ 使用 MENULOAD 加载菜单的步骤：

### 1. 打开中望 CAD

启动 ZWCAD 主程序。

### 2. 输入命令 `MENULOAD`

如上

#### 3. 弹出“加载/卸载自定义设置”窗口

这是中望 CAD 提供的菜单管理器界面。

#### 4. 点击右下角【浏览...】

在弹出的文件选择窗口中，选择你要加载的菜单文件。

**常见文件类型包括：**

| 文件类型         | 用途说明                                     |
| ---------------- | -------------------------------------------- |
| `.mnu` / `.mns`  | AutoCAD/中望传统菜单文件（定义菜单项和按钮） |
| `.cui` / `.cuix` | 新版图形界面文件（可包含 Ribbon、工具栏等）  |
| `.mnl`           | 如果与 `.mns` 同名，会自动加载对应 Lisp 脚本 |

> 例如：选择 `myplugin.mnu` 或 `pluginmenu.cuix`

#### 5. 点击【打开】，再点击【加载】

菜单加载完成后会：
- 在顶部菜单栏新增一个菜单项（例如“插件工具”）
- 或在界面中显示一个新的浮动工具栏

---

#### ✅ 加载成功后你可以：

- 点击菜单或图标按钮来使用插件功能
- 输入插件定义的 Lisp 命令进行调用
- 使用 `CUI` 命令进一步管理、整理菜单和工具栏



## 七，mfc练习：手写计算器

#### 1，创建按钮 修改ID

略

#### 2，按钮事件响应函数

当双击按钮创建一个函数的时候：

✅ 1. 在 `.cpp` 文件中添加一个函数体：

```cpp
void CCalculatorDlg::OnBnClickedBtnNum1()
{
    // 你写逻辑的地方
}
```

✅ 2. 在 `.h` 文件中添加函数声明：

```cpp
afx_msg void OnBnClickedBtnNum1();  // 会加在类 CCalculatorDlg 内部
```

✅ 3. 在 `.cpp` 的 `BEGIN_MESSAGE_MAP` 中添加消息映射：

```cpp
ON_BN_CLICKED(IDC_BTN_NUM1, &CCalculatorDlg::OnBnClickedBtnNum1)
```

#### 3， 计算器逻辑 

GPT全部解决 略





## 八，🧱 ZRX + MFC 二次开发五步流程（正式工作版）

#### 📦 1. 插件功能开发（ZRX + MFC）

##### ✅ 目标：

实现一个实际功能（如计算器、插入图块、批量转换等）

##### 🔧 操作流程：

- 使用 ZRX SDK + Visual Studio 创建插件项目

- 编写命令函数，例如：

  ```cpp
  void MfcFile::ShowCalculator() {
      CCalculator dlg;
      dlg.DoModal(); // 弹出 MFC 对话框窗口
  }
  ```

- 注册命令：

  ```cpp
  acedRegCmds->addCommand(
      _T("MY_CMDS"),
      _T("ShowCalculator"),
      _T("ShowCalculator"),
      ACRX_CMD_MODAL,
      MfcFile::ShowCalculator
  );
  ```

- 编译生成 `.zrx` 插件文件

------

#### 🎨 2. 创建可视化界面（MFC）

##### ✅ 目标：

通过按钮/输入框等控件，实现人机交互

##### 🔧 操作流程：

- 使用资源编辑器新建 Dialog（对话框）
- 添加控件：按钮、编辑框等
- 在 `.h` 文件中添加变量绑定控件
- 实现事件响应函数（如按钮点击、输入处理等）

------

#### 🔘 3. 在 CAD 中注册按钮（CUI 工具栏）

##### ✅ 目标：

让命令变成一个“鼠标可点击”的图标按钮，而非只能手动输入命令行

![1-7](cadpicture/1-7.PNG)

##### 🔧操作步骤：

直接如上图所示：这里的cuix文件是让gpt帮忙生产的



------

#### 🖼️ 4. 设置自定义图标（BMP）

##### ✅ 目标：

使用你自己设计的图标，而不是 CAD 默认图标

##### 🔧 操作流程：

1. 准备 16×16 或 32×32 BMP 图标（如 `calculator_icon_16x16.bmp`）
2. 在 CUI 命令右侧“按钮图像”区域 ➜ 点击“📁 加载图像”
3. 选择你的 `.bmp` 图标并应用

------

#### 💾 5. 保存工作区配置

##### ✅ 目标：

让你的按钮在下次打开 CAD 时自动显示

##### 🔧 操作流程：

1. 输入命令：`WSSAVE`
2. 命名为：`MyWorkspace`
3. 打开选项（`OPTIONS`）设置此工作区为默认启动项

------

#### 📦 6. 插件打包与交付

##### ✅ 目标：

把你的插件作为一个独立工具包发给同事或客户使用

##### ✅ 打包结构推荐：

```
 CalculatorPlugin/
├─ Calculator.zrx              ✅ 插件主程序
├─ MyCalculator.cuix           ✅ 自定义按钮菜单
├─ calculator_icon_16x16.bmp   ✅ 图标文件（可选）
└─ 安装说明.txt                ✅ 安装使用步骤文档
```

##### ✅ 安装说明核心内容：

```txt
1. 输入 APPLOAD ➜ 加载 Calculator.zrx
2. 输入 CUI ➜ 加载 MyCalculator.cuix
3. 拖命令到工具栏 ➜ 勾选显示工具栏
4. 点击按钮 ➜ 弹出计算器窗口
5. 输入 WSSAVE ➜ 保存当前界面
```







## 九，AutoCAD二次开发插件试用

### 1，SMCAD综合工具

#### （1）初始化

1 初始化：可视化界面设置当前图纸的`绘图比例 + 标注精度控制`   

2 快速图框：快速“配置”一个图框类型，然后自动填充一些属性栏和编号：

自动包含：图幅大小、边框、标题栏、填写信息区等内容。

3 图框图标：图签批量管理工具

用来对**已经存在的图框**进行各种智能操作，比如**一键提取信息、一键导出、一键生成图纸目录**等。



#### （2）图号保存

自动保存  只要目前cad空间里有**合规的图** 就会自动保存

![1=8](cadpicture/1=8.PNG)

#### （3）图层操作

1，全开图层：显示所有图层

2，保留选择层：**除了选中的** 其他图层**都关闭**

3， 关闭选择层：**只关闭选中的图层**   这个功能有点蠢感觉



#### （4）换层、超级换层，删除层

1 换层：

就是更简单的换图层

操作方式： 

（1）选中需要更换图层的部分   

（2）点击“换层”按钮

（3）下方出现**选择模板**的时候  点击想要变成的图层   

这样 （1）选中的图层就会变成（3）的图层       

**只能这样操作 其他方式会报错**



2 超级换层：

点开是一个可视化窗口？ 

可以根据颜色 线性 层名来换

但是大体功能还是换图层  没啥区别

可能在实际画图中 复杂形状用起来更方便吧



3， 删除层

这个功能搞不太懂

（1）点击“删除层

（2）选择**指定的图层**   注意是图层 这里不是选择要删除的对象

（3）选择**指定的图层上**的**要删除的对象**   

（4）点击空格执行



这里试验过了  `如果（3）选择了和（2）所选图层不一致的对象 是不会删除的`

好像就是让删除层更智能了  不会误删除



#### （5）SE换层

> **这是一个用于自动处理从 Solid Edge 转换出来的 DWG 图纸的脚本，作用是把原来混乱、无规范的图层，统一批量整理成标准图层，以便后续出图或管理。**





#### （6）清除  我的cad 自动做块

（1）清除图中无用信息

（2）我的cad:

​	**把不需要的图层删掉**，然后自动导入公司规定要用的那些图层，比如常见的 0 层、文字层、标注层、墙体层等等。

​	**调整一些 CAD 的设置**，比如线条的粗细、单位怎么显示、文字和标注用什么样式——这些都按照公司的标准来统一。

​	**可能还会自动插入一些常用图块**，像图框、标题栏之类的东西，省得手动加。

​	**把一些不该改的图层给锁上或冻结**，这样大家就不会误操作。

​	总之就是一键帮你把当前图纸变成“公司标准模板”，不用你一个个去调，画图前直接跑一下，环境就配好了。



(3) 自动做块

这个很简单  就是点击这个功能 然后把选中的对象自动注册成块

在插入块里就能找到



#### `（7）打开块  关闭块`

很诡异  不太清楚这里的打开和关闭是啥意思

##### 如何查看是否为块：



**1 输入 `LIST` 命令**

- 在命令行输入 `LIST`，回车。
- 然后用鼠标点击你想判断的对象。

**2 查看命令行返回的类型**

- 如果显示的是：

  ```
  INSERT  图层: xxx
  块名: xxx
  ```

  ✅ 说明这是一个块（Block）。

- 如果显示的是：

  ```
  LWPOLYLINE / LINE / CIRCLE / TEXT 等
  ```

  ❌ 那就不是块，只是普通图元。

**注意事项**

- **变形（如拉伸、缩放）后的块，只要没被炸开，依然是块。**
- **使用 `EXPLODE` 炸开后，对象将变成普通图元，不再是块。**





#### 如何删除块的定义：

**1 输入 `purge` 命令**



**2 通过可视化界面删除**





#### （8）遮盖文字

这个功能只对这两个生效

1 text或者mtext插入的文字

2 标注

但是没啥反应 选中了文字也没有遮盖





#### （9）绘制中心线 角焊缝

1 中心线：  就是选择两个直线的中点画一条线

2 角焊缝： 偏机械了  感觉不需要学 反正满足角焊缝就能画   估计是需要两块机械板子



#### （10）特殊图形的绘制

1 特殊线条： 很简单就是一堆特殊线条

2 常用形状： 同理就是一堆特殊形状 直接插入就行

3 机械制图：完全不懂  大概就是按需要插入一些标注或者其他的东西

4 螺纹界面

5 螺纹孔     都是同理  和编程无关 就是画一个东西





#### （11）图案填充

1 Cad自带图案填充：  等于输入了hatch  只是为了更方便的打开图案填充这个界面

2 myhatch: 完全看不懂



#### （12）诡异的插件

1 智能图库： 应该是公司的一系列图库 

插入分为 **块插入**   和 **爆炸插入**

| 插入方式 | 是否为块 | 是否整体可选 | 可重复引用 | 可统一更新 | 可被插件识别 |
| -------- | -------- | ------------ | ---------- | ---------- | ------------ |
| 块插入   | ✅ 是     | ✅ 是         | ✅ 可以     | ✅ 可以     | ✅ 识别到     |
| 爆炸插入 | ❌ 否     | ❌ 分散       | ❌ 不方便   | ❌ 不统一   | ❌ 识别不到   |



2 smartno

打得开 说是智能标注用的



3 DDTools

一个文件处理的相关插件  具体直接问吧



4  文档切换

感觉就是顾名思义 在不同的画图dwg文件里切换



5  仿图纸显示

完全不懂



6  智能关闭

一建保存+关闭







### 2，SMCAD增强编辑

**1 立即删除**

就是立即删除某个对象 





**2 轴镜像**

顾名思义



**3 偏移**

有点诡异  但是大体就是复制某个图形然后位移到其他地方



**4  拉伸**

顾名思义



**5 延伸**

--不纠结了 没感觉出啥区别 就是普通的眼神

`主要是要先选择作为延伸终点的线  再选择要延伸的对象`



下面这些都是选择延伸对象的方法



**（1）栏选（W）**
 拉一条直线，凡是被这条线穿过的图形都会被选中。

**（2）窗交（C）**
 从右下往左上拉一个蓝色框，
 **只要碰到一点点的对象都会被选中**。

**（3）投影（P）**
 控制线条延伸的方向，
 **一般用默认的就行，不需要管**。

**（4）边缘（E）**
 如果边界线没画到位，
 这个选项可以让 CAD **假装边界线是无限延长的**，



**6 无边界延伸修建**

更智能的延伸？





**7 打断于点**

把一条线从你点的地方剪成两段，常用于插入符号或分段标注

注意 `眼睛是看不出来的 需要选中才能看到确实被 分成两端了`



**8 循环爆炸**

懒得试了 就当是爆炸块吧



**9 接线或者字**

目前来看 真的就是连接两根线？

但是连接方式未知



**10 修建中心线**

这个功能很有意思  可以用**综合工具里的中心线**测试

功能是中心线一般都会在两头过长

![1-8](cadpicture/1-8.PNG)



比如上图 这个**红色中心线**本来比较长的  这个功能可以修建中心线的两边 让他比如只突出n厘米  这个n可以自己定义



**11 截交**

很简单  选两条线 他们就会自动相交



`**12 倒角标注 圆角标注**`

比较专业 是机械制图里的特有概念

感觉没必要懂 需要再说吧







`**13 局部放大**`

巨神奇的功能 完全不懂







### 3，SMCAD增强绘图

这个整体都简单



简单的操作捕捉开关  画辅助线



那个删除辅助线的工具点一下全删了





### 4，SMCAD文字标注

#### （1）角度 长度标注等

简单 知道就行了



#### （2）粗糙度 格式化标注





#### （3）文字标注

单纯的插入单行和多行文字  也不用管



### 5. SMCAD工艺管道

画一堆管道 具体看需要再学