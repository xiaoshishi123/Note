# EDA/Linux学习

### 一，linux



#### 1，常用linux命令

inux 本质上是一个**更接近底层**的操作系统，允许你用命令直接跟电脑“说话”。
 它不像 Windows 那样把一切包装成图标，而是把原始的力量交给你。

对开发测试岗位来说，Linux 就两个用处：

1. **跑程序**（EDA、服务、脚本）
2. **查问题**（日志、进程、资源）

这就决定了你其实不需要学很多命令，但要知道为什么它们重要。



##### 1）目录 & 文件操作（像在大房子里走路）

```bash
ls -lh          # 以人类可读的方式列出当前目录下文件（h = human-readable）
ls -a           # 显示所有文件，包括隐藏文件（以 . 开头）
cd /path        # 切换到指定目录
pwd             # 显示当前所在目录的绝对路径
mkdir test      # 创建名为 test 的目录
rm -rf test     # 递归删除 test 目录及其全部内容（危险操作，慎用）
```

理解方式：

- `ls`：看看家里有什么
- `cd`：走到另一个房间
- `pwd`：告诉你现在在哪
- `rm -rf`：拆房子（慎用）

职场典型场景：
 “去日志目录看报错文件。”
 “把运行结果放到指定目录。”

------

##### 2）查看文件内容（EDA 场景最常用）

```bash
cat file.log            # 直接输出文件内容到控制台（适合查看小文件）
less file.log           # 分页查看文件，可上下翻页，适合大文件
tail -n 100 file.log    # 查看文件末尾的 100 行内容
tail -f file.log        # 实时输出文件新增内容（常用于监控运行日志）
grep "error" file.log   # 在文件中查找包含 "error" 的行
grep -r "timeout" .     # 在当前目录递归查找包含 "timeout" 的文件内容
```

理解方式：

- `tail -f` 是实时看日志，就像盯着流水线产品滚出来。
- `grep` 是搜索关键词，很像 Ctrl+F 的加强版。

典型场景：
 “测试失败了，去 tail -f 看脚本输出。”
 “grep 一下 error 找到失败原因。”

------

##### 3）执行脚本（你以后会最常用）

```bash
chmod +x run.sh     # 为脚本添加可执行权限（x = execute）
./run.sh            # 执行当前目录下的脚本
bash run.sh         # 使用 bash 明确执行脚本（适用于无执行权限或 shebang 不明确）
```

用法含义：

- “让脚本有执行权限”
- “跑它”

典型场景：
 “EDA 工具执行环境一般都靠脚本启动。”

------

##### 4）查看进程和系统资源（不需要深度运维）

```bash
top                        # 实时查看 CPU、内存等系统资源使用情况
ps -ef | grep python       # 查找包含 python 字样的进程
kill -9 PID                # 强制结束指定 PID 的进程（-9 = 强制终止）
```

理解方式：

- `top` 是看 CPU/内存是否爆了
- `ps` 是找“谁在干活”
- `kill` 就是终止作业

典型场景：
 “仿真卡死了，用 ps 找进程，然后 kill 掉重来。”

------

##### 5）解压缩（你可能会很常用）

```bash
tar -zxvf file.tar.gz      # 解压 .tar.gz 文件（z=解压gz，x=解包，v=显示过程，f=指定文件）
unzip file.zip             # 解压 .zip 文件
```

典型场景：
 “EDA 工具包、测试样例包都常用 tar.gz 形式。”







#### 2，你在 Linux 下主要会做哪些操作？

- 使用 `cd` / `ls` / `pwd` / `mkdir` / `rm -rf` 等进行目录和文件管理；
- 用 `tail -f`、`grep`、`less` 查看和分析日志输出；
- 用 `chmod +x`、`./run.sh` 或直接执行 Perl 脚本跑工具流程；
- 用 `ps -ef | grep xxx`、`top` 等查看进程和资源使用情况。







#### 3，如何在 Linux 下定位一个工具运行失败的原因？

**A：**

一般会做几步：

1. 查看工具的**退出码**（`echo $?`）；
2. 查看对应的**日志文件**（例如 `tail -n 100 xxx.log`）；
3. 使用 `grep "error"` / `grep "warning"` 过滤关键字；
4. 对照命令参数或输入文件，尝试**最小化用例**去复现问题。



#### 4，什么时候会用到 `grep -r`？给个例子。

**A：**

当我要在一个目录下递归搜索某个错误信息或关键字时：

```
grep -r "out of memory" .
```

可以快速定位是哪个文件、哪一行产生了这个报错，方便进一步分析。











### 二，EDA

EDA 其实就是一句话：

> **用软件工具链完成芯片设计、验证、布局布线、生成版图的全过程自动化。**

就像你用 IntelliJ 写 Java，再跑编译器、测试、调试一样。
 只不过芯片的“编译”和“测试”，复杂到离谱，需要专业的软件来做。

从程序员视角看，芯片开发流程 ≈ 一个超大型的软件工程，只不过：

- 源码不是 Java/C++，而是 **硬件描述语言（HDL，例如 Verilog、VHDL）**
- 编译器不是 javac，而是 **综合器（Synthesis Tool）**
- 测试不是 JUnit，而是 **仿真器（Simulator）**
- 运行环境不是 JVM，而是 **FPGA/流片出来的真实芯片**

你面试的**EDA 测试/工具链岗位**，本质上就是：

**在 Linux 下跑 EDA 工具 → 获取结果 → 对比预期 → 定位问题 → 提交报告。**



#### 1， 芯片设计流程是什么？

知道从 HDL → 仿真 → 综合 → 布局布线 → 时序分析 → 版图 → 流片。



#### 2，EDA核心流程

##### **2.1 HDL 设计（写代码）**

- Verilog / VHDL
- 逻辑描述（计数器、状态机、运算单元等）

##### **2.2 仿真 Simulation（单元测试 + 集成测试）**

- 作用：验证逻辑功能是否正确
- 工具：华大九天的模拟器、开源 Icarus Verilog 等
- 输出：波形文件（VCD、FSDB）

##### **2.3 综合 Synthesis（编译）**

- 将 Verilog 转成电路级形式（门级网表）

##### **2.4 布局布线 Place & Route（资源分配 + 连线）**

- 把逻辑单元放在芯片上
- 自动拉线连接
- 解决拥塞

##### **2.5 静态时序分析 STA（性能分析）**

- 验证电路是否能在目标频率下工作
- “延时路径”对应软件的“慢函数”

##### **2.6 DRC/LVS（静态检查）**

- DRC：版图是否违反物理规则
- LVS：电路与版图是否一致
- 类比：Linter + Static Checker

##### **2.7 最终版图 GDS（Release 包）**

- 交付台积电/中芯国际制造





#### 3， Verilog/VHDL 要不要精通？

不需要精通，但至少知道是什么：

> “Verilog 就像硬件世界的 C 语言，用来描述电路结构和行为。”





#### 4，你在 EDA 部门要掌握什么（面试 & 入职通吃）

以下内容是**用户画像 = 你**必须掌握的基础能力。
 你复制过去就是你的“技能清单 + 学习路线”。

##### **4.1 Linux 基础操作（真实岗位必备）**

- 基础命令（ls, grep, tail, ps, top）
- 文件权限 chmod
- 执行脚本（bash、sh）
- 处理大日志文件

🔑 **重点：所有 EDA 工具都运行在 Linux 上。**

------

##### **4.2 脚本语言（Tcl / Python / Shell）**

为什么 Tcl 很重要？

> 绝大多数 EDA 工具（全世界）都用 Tcl 做流程驱动脚本。

你不需要精通，只需达到：

- 会看
- 会改配置
- 会写简单流程（for/if）

Python 的用途：

- 自动化测试
- 读取日志
- 校验运行结果
- 批量任务执行

------

##### **4.3 Verilog/VHDL 的最基础理解（只要能解释）**

你不设计芯片，但必须理解：

- HDL 是用来描述电路的代码
- 语句类型：组合逻辑 always_comb、时序逻辑 always_ff
- 模块 module 的概念
- testbench 是测试代码

面试官问你不会深入问，只需解释得通。

------

##### **4.4 EDA 仿真流程操作（部门内最常用）**

你需要知道怎么：

- 运行仿真脚本
- 读取仿真输出
- 查看波形文件（VCD）
- 跟预期结果比对
- 提交 bug 说明

------

##### **4.5 工具链测试流程（你岗位的核心能力）**

EDA 测试的本质是：

> **大量跑工具 → 分析结果 → 对比预期 → 自动化验证工具链正确性。**

你需要掌握：

- 怎么批量运行工具（脚本）
- 怎么分析错误日志
- 怎么复现 bug
- 怎么最小化测试用例
- 怎么和研发沟通定位问题

------

##### **4.6 常见 EDA 文件格式（了解）**

你只需知道这些是什么，不用会写：

| 格式             | 用途         |
| ---------------- | ------------ |
| **Verilog/VHDL** | 逻辑描述     |
| **SDF**          | 时序延迟文件 |
| **LEF/DEF**      | 版图层级信息 |
| **GDSII**        | 最终芯片版图 |
| **VCD/FSDB**     | 波形文件     |

知道“是什么”就够应付面试。

------

##### **4.7 Debug 能力（你最需要展现的能力）**

EDA 的 debug 没想象的那么玄，其实就两类：

###### **① 工具报错（通常是日志排查）**

- 看报错行
- 找输入文件
- 确认脚本参数
- 复现问题

###### **② 对比 golden result（黄金结果）**

- 多跑几组数据
- 记录差异
- 把最小化 case 提给研发

这和你现在调 Java Bug 非常相似。







### 三，八股文

#### Q1：什么是 EDA？

**A：**
 EDA 是 *Electronic Design Automation*，即**电子设计自动化**，简单说就是：

> 用软件工具链完成芯片从“代码描述”到“物理版图”的整个设计与验证过程。

它包含仿真、综合、布局布线、时序分析、物理检查等一整套工具。



#### Q2：芯片设计的大致流程是怎样的？

**A：**

可以按下面几个关键步骤记：

1. **RTL 设计**：用 Verilog/VHDL 编写功能逻辑（类似写代码）。
2. **仿真（Simulation）**：用仿真器验证功能是否正确。
3. **综合（Synthesis）**：把 RTL 转换成门级网表（逻辑门电路）。
4. **布局布线（Place & Route）**：在芯片上摆放单元并自动拉线。
5. **时序分析（STA）**：检查在目标频率下是否能满足时序要求。
6. **物理验证（DRC/LVS）**：检查版图是否符合工艺规则、是否与电路一致。
7. **生成版图文件（如 GDSII）**：交给晶圆厂流片制造。



#### Q3：仿真（Simulation）是做什么的？和软件里的“测试”有什么关系？

**A：**
 仿真是把设计写成 testbench，给输入激励，观察输出波形，验证设计是否符合规格。

可以类比为：

> 硬件世界的单元测试 + 集成测试，通过波形/日志而不是控制台输出来看结果。





#### Q4：静态时序分析（STA）是什么？为什么重要？

**A：**

- STA 分析的是**信号的延迟和时序约束**，检查在某个频率下是否所有路径都能按时到达。
- 不像动态仿真跑具体输入，STA 不依赖具体激励，而是分析“所有可能路径”的最坏情况。

类比为：

> 软件里的性能分析，但更偏“理论上所有路径是否都能在 deadline 内完成”。



#### Q5：DRC 和 LVS 是什么？

**A：**

- **DRC（Design Rule Check）**：检查版图有没有违反工艺规则（例如线宽、间距等）。
- **LVS（Layout Versus Schematic）**：检查版图和电路网表是否一致。

你可以一句话总结：

> DRC 看“形式合不合规矩”，LVS 看“实际连法对不对”。



#### Q6：作为 EDA 测试工程师，需要到什么程度理解这些流程？

**A：**

不用自己设计芯片，但要做到：

- **听得懂**工具在流程里的位置（是仿真？综合？P&R？）
- **看得懂**工具输入输出大概是什么类型（RTL/网表/版图/波形等）
- **知道**它的主要目的，比如“验证功能”“检查时序”“做物理规则检查”。





